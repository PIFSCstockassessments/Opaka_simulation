## Calculate RE across multiple OM/EMs

#' Calculate relative error
#'
#' Calculate the relative error (RE; \eqn{[EM - OM]/OM}) of
#' parameters and derived quantities stored in a scalar or time series
#' data frame generated by [get_results_all()].
#'
#' @param dat An input data frame. Should be either a scalar or time series
#'   data frame as returned from [get_results_all()] or a related
#'   `get_results_*()`. Specifically, the data frame needs to have columns
#'   with `_em` and `_om` as names. If the data is provided in long
#'   rather than wide format, then [convert_to_wide()] will be used
#'   internally before calculating RE and a wide data frame will be returned.
#' @param add Logical: should the relative error columns be added to `dat`
#'   or should the original EM and OM columns be dropped? If `FALSE`, then
#'   the returned data frame will have only the identifying columns and the new
#'   relative error columns. You could then merge selected columns back into
#'   `dat` if you wished. The default is to return all columns.
#' @param EM A character value specifying the name of the EM to calculate the
#'   RE of when the results are provided in long format and there is the potential
#'   for multiple EMs. See the column `model_run` for options.
#' @param OM A character value specifying the name of the OM to calculate the RE. 
#' @author Sean Anderson and Cole Monnahan
#' @seealso [get_results_all()], [get_results_scenario()]
#' @return The default is to return a data frame structured the same as the
#' input data frame, i.e., `dat`, but with additional columns, where
#' `'_re'` is appended to the base string of the column name.
#' All `NAN` and `Inf` values are returned as `NA` values,
#' typically because you cannot divide by zero. Irrelevant columns, i.e.,
#' columns of entirely zero of `NA` are removed prior to returning the
#' data frame.
#' @export
#' @examples
#' # Example with built in package data:
#' data("ts_dat", package = "ss3sim")
#' data("scalar_dat", package = "ss3sim")
#' head(calculate_re(ts_dat))
#' head(calculate_re(ts_dat, add = FALSE))
#' head(calculate_re(scalar_dat, add = FALSE))
#' rm("ts_dat", "scalar_dat")
calculate_re_MO <- function(dat, add = TRUE, EM = "em", OM = "om") {
  # Check if wide or long data
  if ("model_run" %in% colnames(dat)) {
    stopifnot(length(EM) == 1)
    dat <- convert_to_wide_MO(dat[dat$model_run %in% c(OM, EM), ], OM, EM)
  }
  both <- intersect(
    gsub("_em", "", grep("_em", names(dat), value = TRUE)),
    gsub("_om", "", grep("_om", names(dat), value = TRUE))
  )
  both <- both[order(both)]
  em_names <- paste0(both, "_em")
  om_names <- paste0(both, "_om")

  re <- (dat[, em_names] - dat[, om_names]) /
    dat[, om_names]
  names(re) <- gsub("_em", "_re", names(re))

  # strip out NLL
  # strip out columns of all NAs or zeros
  re <- re[, !grepl("NLL", names(re))]
  re[is.na(re)] <- NA
  re[is.infinite(as.matrix(re))] <- NA
  re <- re[, apply(re, 2, function(x) !all(x %in% c(NA, 0)))]
  # Remove all OM and EM columns if only returning RE
  if (!add) {
    data.frame(dat[, !grepl("_om|_em", colnames(dat))], re)
  } else {
    data.frame(dat, re)
  }
}


#' Convert long-style ss3sim output to wide format
#'
#' This function exists for back compatibility. Added OM and EM 
#' parameters so that user can specify which OM/EM runs they want to use.
#' @param lng A long dataframe produced from get_results_all().
#' @param OM A character value specifying the name of the OM
#' @param EM A character value specifying the name of the EM
#' @return A wide dataframe (separate columns for em and om results)
#' @export
#' @examples \dontrun{
#' scalar <- utils::read.csv("ss3sim_scalar.csv")
#' scalar_wide <- convert_to_wide(scalar)
#'
#' ts <- utils::read.csv("ss3sim_ts.csv")
#' ts_wide <- convert_to_wide(scalar)
#' }
#' @author Kathryn L. Doering

convert_to_wide_MO <- function(lng, OM = "om", EM = "em") {
  em_df <- lng[lng$model_run == EM, , drop = FALSE]
  colnames(em_df) <- paste0(colnames(em_df), "_em")
  which(colnames(em_df) %in% c("iteration_em", "scenario_em"))
  colnames(em_df)[colnames(em_df) == "iteration_em"] <- "iteration"
  colnames(em_df)[colnames(em_df) == "scenario_em"] <- "scenario"
  if ("year_em" %in% colnames(em_df)) {
    colnames(em_df)[colnames(em_df) == "year_em"] <- "year"
  }
  colnames(em_df)[colnames(em_df) == "max_grad_em"] <- "max_grad"
  colnames(em_df)[colnames(em_df) == "version_em"] <- "version"
  colnames(em_df)[colnames(em_df) == "RunTime_em"] <- "RunTime"
  colnames(em_df)[colnames(em_df) == "hessian_em"] <- "hessian"
  colnames(em_df)[colnames(em_df) == "Niterations_em"] <- "Niterations"
  em_df <- em_df[, setdiff(colnames(em_df), c("X_em", "model_run_em"))]

  om_df <- lng[lng$model_run == OM, , drop = FALSE]
  colnames(om_df) <- paste0(colnames(om_df), "_om")
  colnames(om_df)[colnames(om_df) == "iteration_om"] <- "iteration"
  colnames(om_df)[colnames(om_df) == "scenario_om"] <- "scenario"
  if ("year_om" %in% colnames(om_df)) {
    colnames(om_df)[colnames(om_df) == "year_om"] <- "year"
  }
  # remove some columns
  om_df <- om_df[, setdiff(
    colnames(om_df),
    c(
      "max_grad_om", "version_om", "RunTime_om",
      "hessian_om", "Niterations_om",
      "params_on_bound_om", "params_stuck_low_om",
      "params_stuck_high_om", "X_om", "model_run_om"
    )
  )]
  # merge back together
  wide <- merge(om_df, em_df, all = TRUE)
  wide <- wide[, apply(wide, 2, function(x) !all(is.na(x)))]

  # add in old cols
  wide$ID <- paste0(wide$scenario, "-", wide$iteration)

  # add code to divide ID into the different codes and species
  ## parse the scenarios into columns for plotting later
  # use this old code:
  new_cols <-
    data.frame(
      do.call(rbind, strsplit(gsub(
        "([0-9]+-)", "\\1 ",
        as.character(wide$scenario)
      ), "- ")),
      stringsAsFactors = FALSE
    )
  names(new_cols) <-
    c(substr(as.vector(as.character(
      new_cols[1, -ncol(new_cols)]
    )), 1, 1), "species")
  wide <- cbind(wide, new_cols)
}
